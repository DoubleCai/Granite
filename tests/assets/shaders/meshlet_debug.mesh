#version 450
#extension GL_EXT_mesh_shader : require

layout(max_primitives = 128, max_vertices = 128, triangles) out;
#include "meshlet_payload_constants.h"
layout(local_size_x = 128) in;

layout(constant_id = 0) const uint NUM_U32_STREAMS = MESHLET_PAYLOAD_MAX_STREAMS;
#define MESHLET_PAYLOAD_NUM_U32_STREAMS NUM_U32_STREAMS

#define MESHLET_PAYLOAD_DESCRIPTOR_SET 0
#define MESHLET_PAYLOAD_META_BINDING 3
#define MESHLET_PAYLOAD_STREAM_BINDING 4
#define MESHLET_PAYLOAD_PAYLOAD_BINDING 5
#include "meshlet_payload_decode.h"
#include "meshlet_attribute_decode.h"

#define MESHLET_RENDER_DESCRIPTOR_SET 0
#define MESHLET_RENDER_AABB_BINDING 0
#define MESHLET_RENDER_TRANSFORM_BINDING 1
#define MESHLET_RENDER_TASKS_BINDING 2
#define MESHLET_RENDER_BOUND_BINDING 7
#define MESHLET_RENDER_FRUSTUM_BINDING 8
#include "meshlet_render.h"

#if 0
layout(location = 0) out mediump vec3 vNormal[];
layout(location = 1) out mediump vec4 vTangent[];
layout(location = 2) out vec2 vUV[];
layout(location = 3) perprimitiveEXT out uint MaterialOffset[];
#else
layout(location = 0) out vec3 vWorldPos[];
layout(location = 1) perprimitiveEXT out uint vDrawID[];
#endif

layout(set = 1, binding = 0) uniform UBO
{
    mat4 VP;
};

layout(set = 1, binding = 2) uniform UBOViewport
{
    vec4 viewport;
};

#ifndef MESHLET_RENDER_TASK
#error "Must define MESHLET_RENDER_TASK"
#endif

#if MESHLET_RENDER_TASK
taskPayloadSharedEXT CompactedDrawInfo mesh_payload[32 * 32];
#else
layout(set = 0, binding = 10) readonly buffer DrawInfos
{
    CompactedDrawInfo mesh_payload[];
};
#endif

shared vec2 shared_window_positions[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared uint8_t shared_clip_code[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared uvec4 shared_active_vert;
shared uvec4 shared_active_prim;
shared uvec4 shared_active_vert_count;
shared uvec4 shared_active_prim_count;

const uint CLIP_CODE_NEGATIVE_W = 1;
const uint CLIP_CODE_INACCURATE = 2;

uint compacted_vertex_output(uint index)
{
	return shared_active_vert_count[index / 32u] + bitCount(shared_active_vert[index / 32u] & ((1u << (index & 31u)) - 1u));
}

uint compacted_index_output(uint index)
{
	return shared_active_prim_count[index / 32u] + bitCount(shared_active_prim[index / 32u] & ((1u << (index & 31u)) - 1u));
}

bool lane_has_active_vert(uint index)
{
	return (shared_active_vert[index / 32u] & (1u << (index & 31u))) != 0u;
}

uvec3 remap_index_buffer(uvec3 prim)
{
    return uvec3(compacted_vertex_output(prim.x),
        compacted_vertex_output(prim.y),
        compacted_vertex_output(prim.z));
}

bool cull_triangle(vec2 a, vec2 b, vec2 c)
{
	// To be completely accurate, this should be done in fixed point,
	// but we can YOLO a bit since glitches in extreme edge cases are considered okay.
	precise vec2 ab = b - a;
	precise vec2 ac = c - a;

	// This is 100% accurate as long as the primitive is no larger than ~4k subpixels, i.e. 16x16 pixels.
	// Normally, we'd be able to do GEQ test, but GE test is conservative, even with FP error in play.
	precise float neg_area = ab.x * ac.y;
	precise float pos_area = ab.y * ac.x;
	if (neg_area > pos_area)
		return false;

	// Micropoly test.
	vec2 lo = floor(ldexp(min(min(a, b), c), ivec2(-8)));
	vec2 hi = floor(ldexp(max(max(a, b), c), ivec2(-8)));
	return all(notEqual(lo, hi));
}

void main()
{
    if (gl_LocalInvocationIndex < MESHLET_PAYLOAD_NUM_CHUNKS)
    {
        shared_active_vert[gl_LocalInvocationIndex] = 0;
        shared_active_prim[gl_LocalInvocationIndex] = 0;
    }

    CompactedDrawInfo task = mesh_payload[gl_WorkGroupID.x];
    MeshletMetaRuntime meta = meshlet_metas_runtime.data[task.meshlet_index];
    meshlet_init_workgroup(meta.stream_offset);

	uint linear_index = meshlet_get_linear_index();
    mat4 M = transforms.data[task.node_offset];

    uvec3 prim;
#define INDEX(index, value) prim = uvec3(unpack8(value).xyz)
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 0, INDEX);

	vec3 pos;
#define POSITION(index, value) pos = attribute_decode_snorm_exp_position(value)
    MESHLET_DECODE_STREAM_64(meta.stream_offset, 1, POSITION);

	vec3 world_pos = (M * vec4(pos, 1.0)).xyz;
	vec4 clip_pos = VP * vec4(world_pos, 1.0);
	vec2 c = clip_pos.xy / clip_pos.w;
	uint clip_code = clip_pos.w <= 0.0 ? CLIP_CODE_NEGATIVE_W : 0;
	if (any(greaterThan(abs(c), vec2(4.0))))
		clip_code |= CLIP_CODE_INACCURATE;
	vec2 window = roundEven(c * viewport.zw + viewport.xy);
	shared_window_positions[linear_index] = window;
	shared_clip_code[linear_index] = uint8_t(clip_code);

    barrier();

	bool is_active_prim = false;
    if (linear_index < meta.num_primitives)
    {
        vec2 a = shared_window_positions[prim.x];
        vec2 b = shared_window_positions[prim.y];
        vec2 c = shared_window_positions[prim.z];
        uint code_a = shared_clip_code[prim.x];
        uint code_b = shared_clip_code[prim.y];
        uint code_c = shared_clip_code[prim.z];

        uint or_code_a = code_a | code_b | code_c;
        uint and_code_a = code_a & code_b & code_c;

        if ((and_code_a & CLIP_CODE_NEGATIVE_W) == 0)
        {
            if ((or_code_a & CLIP_CODE_INACCURATE) != 0 || cull_triangle(a, b, c))
            {
				is_active_prim = true;
                atomicOr(shared_active_prim[linear_index / 32], 1u << (linear_index & 31));
                atomicOr(shared_active_vert[prim.x / 32], 1u << (prim.x & 31));
                atomicOr(shared_active_vert[prim.y / 32], 1u << (prim.y & 31));
                atomicOr(shared_active_vert[prim.z / 32], 1u << (prim.z & 31));
            }
        }
    }

    barrier();

    if (gl_LocalInvocationIndex == 0)
    {
		uvec3 num_active_prim = bitCount(shared_active_prim.xyz);
		num_active_prim.y += num_active_prim.x;
		num_active_prim.z += num_active_prim.y;
		shared_active_prim_count = uvec4(0, num_active_prim);

		uvec3 num_active_vert = bitCount(shared_active_vert.xyz);
		num_active_vert.y += num_active_vert.x;
		num_active_vert.z += num_active_vert.y;
		shared_active_vert_count = uvec4(0, num_active_vert);
	}

    barrier();

	uint num_verts = shared_active_vert_count.w + bitCount(shared_active_vert.w);
	uint num_prims = shared_active_prim_count.w + bitCount(shared_active_prim.w);

    SetMeshOutputsEXT(num_verts, num_prims);

	if (is_active_prim)
		gl_PrimitiveTriangleIndicesEXT[compacted_index_output(linear_index)] = remap_index_buffer(prim);

    if (gl_LocalInvocationIndex < num_prims)
        vDrawID[gl_LocalInvocationIndex] = task.meshlet_index;

	bool has_active_vert = lane_has_active_vert(linear_index);

	if (has_active_vert)
	{
        uint out_vert_index = compacted_vertex_output(linear_index);
		gl_MeshVerticesEXT[out_vert_index].gl_Position = clip_pos;
		vWorldPos[out_vert_index] = world_pos;
	}

#if 0
#define NORMAL(index, value) \
    if (index < meta.num_attributes) \
    { \
        vNormal[index] = mat3(M) * attribute_decode_oct8_normal_tangent(value).xyz; \
    }
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 3, NORMAL);

#define TANGENT(index, value) \
    if (index < meta.num_attributes) \
    { \
        mediump vec4 T = attribute_decode_oct8_normal_tangent(value); \
        vTangent[index] = vec4(mat3(M) * T.xyz, T.w); \
    }
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 4, TANGENT);

#define UV(index, value) \
    if (index < meta.num_attributes) \
    { \
        vUV[index] = attribute_decode_snorm_exp_uv(value); \
    }
    MESHLET_DECODE_STREAM_64(meta.stream_offset, 5, UV);
#endif
}
