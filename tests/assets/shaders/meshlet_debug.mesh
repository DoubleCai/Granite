#version 450
#extension GL_EXT_mesh_shader : require

layout(max_primitives = 256, max_vertices = 255, triangles) out;

#include "meshlet_payload_constants.h"

#if MESHLET_PAYLOAD_LARGE_WORKGROUP
#define MESHLET_PAYLOAD_WG_Y MESHLET_PAYLOAD_NUM_CHUNKS
#else
#define MESHLET_PAYLOAD_WG_Y 1
#endif
layout(local_size_x = 32, local_size_y = MESHLET_PAYLOAD_WG_Y) in;

layout(constant_id = 0) const uint NUM_U32_STREAMS = MESHLET_PAYLOAD_MAX_STREAMS;
#define MESHLET_PAYLOAD_NUM_U32_STREAMS NUM_U32_STREAMS

#define MESHLET_PAYLOAD_DESCRIPTOR_SET 0
#define MESHLET_PAYLOAD_META_BINDING 3
#define MESHLET_PAYLOAD_STREAM_BINDING 4
#define MESHLET_PAYLOAD_PAYLOAD_BINDING 5
#include "meshlet_payload_decode.h"
#include "meshlet_attribute_decode.h"

#define MESHLET_RENDER_DESCRIPTOR_SET 0
#define MESHLET_RENDER_AABB_BINDING 0
#define MESHLET_RENDER_TRANSFORM_BINDING 1
#define MESHLET_RENDER_TASKS_BINDING 2
#define MESHLET_RENDER_BOUND_BINDING 7
#define MESHLET_RENDER_FRUSTUM_BINDING 8
#include "meshlet_render.h"

#if 0
layout(location = 0) out mediump vec3 vNormal[];
layout(location = 1) out mediump vec4 vTangent[];
layout(location = 2) out vec2 vUV[];
layout(location = 3) perprimitiveEXT out uint MaterialOffset[];
#else
layout(location = 0) out vec3 vWorldPos[];
layout(location = 1) perprimitiveEXT out uint vDrawID[];
#endif

layout(set = 1, binding = 0) uniform UBO
{
    mat4 VP;
};

#ifndef MESHLET_RENDER_TASK
#error "Must define MESHLET_RENDER_TASK"
#endif

#if MESHLET_RENDER_TASK
taskPayloadSharedEXT CompactedDrawInfo mesh_payload[32 * 32];
#else
layout(set = 0, binding = 10) readonly buffer DrawInfos
{
    CompactedDrawInfo mesh_payload[];
};
#endif

void main()
{
    CompactedDrawInfo task = mesh_payload[gl_WorkGroupID.x];
    MeshletMetaRuntime meta = meshlet_metas_runtime.data[task.meshlet_index];
    meshlet_init_workgroup(meta.stream_offset);

    SetMeshOutputsEXT(meta.num_attributes, meta.num_primitives);

    mat4 M = transforms.data[task.node_offset];

#define INDEX(index, value) \
    if (index < meta.num_primitives) \
    { \
        gl_PrimitiveTriangleIndicesEXT[index] = uvec4(unpack8(value)).xyz; \
    }
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 0, INDEX);

#if MESHLET_PAYLOAD_LARGE_WORKGROUP
    if (gl_LocalInvocationIndex < meta.num_primitives)
        vDrawID[gl_LocalInvocationIndex] = task.meshlet_index;
#else
    for (uint i = gl_LocalInvocationIndex; i < meta.num_primitives; i += 32)
        vDrawID[i] = task.meshlet_index;
#endif

#define POSITION(index, value) \
    if (index < meta.num_attributes) \
    { \
        vec3 pos = attribute_decode_snorm_exp_position(value); \
        vec3 world_pos = (M * vec4(pos, 1.0)).xyz; \
        vWorldPos[index] = world_pos; \
        gl_MeshVerticesEXT[index].gl_Position = VP * vec4(world_pos, 1.0); \
    }
    MESHLET_DECODE_STREAM_64(meta.stream_offset, 1, POSITION);

#if 0
#define NORMAL(index, value) \
    if (index < meta.num_attributes) \
    { \
        vNormal[index] = mat3(M) * attribute_decode_oct8_normal_tangent(value).xyz; \
    }
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 3, NORMAL);

#define TANGENT(index, value) \
    if (index < meta.num_attributes) \
    { \
        mediump vec4 T = attribute_decode_oct8_normal_tangent(value); \
        vTangent[index] = vec4(mat3(M) * T.xyz, T.w); \
    }
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 4, TANGENT);

#define UV(index, value) \
    if (index < meta.num_attributes) \
    { \
        vUV[index] = attribute_decode_snorm_exp_uv(value); \
    }
    MESHLET_DECODE_STREAM_64(meta.stream_offset, 5, UV);
#endif
}