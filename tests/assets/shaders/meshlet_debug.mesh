#version 450
#extension GL_EXT_mesh_shader : require

layout(max_primitives = 128, max_vertices = 128, triangles) out;
#include "meshlet_payload_constants.h"
layout(local_size_x = 128) in;

layout(constant_id = 0) const uint NUM_U32_STREAMS = MESHLET_PAYLOAD_MAX_STREAMS;
#define MESHLET_PAYLOAD_NUM_U32_STREAMS NUM_U32_STREAMS

#define MESHLET_PAYLOAD_DESCRIPTOR_SET 0
#define MESHLET_PAYLOAD_META_BINDING 3
#define MESHLET_PAYLOAD_STREAM_BINDING 4
#define MESHLET_PAYLOAD_PAYLOAD_BINDING 5
#include "meshlet_payload_decode.h"
#include "meshlet_attribute_decode.h"

#define MESHLET_RENDER_DESCRIPTOR_SET 0
#define MESHLET_RENDER_AABB_BINDING 0
#define MESHLET_RENDER_TRANSFORM_BINDING 1
#define MESHLET_RENDER_TASKS_BINDING 2
#define MESHLET_RENDER_BOUND_BINDING 7
#define MESHLET_RENDER_FRUSTUM_BINDING 8
#include "meshlet_render.h"

#if 0
layout(location = 0) out mediump vec3 vNormal[];
layout(location = 1) out mediump vec4 vTangent[];
layout(location = 2) out vec2 vUV[];
layout(location = 3) perprimitiveEXT out uint MaterialOffset[];
#else
layout(location = 0) out vec3 vWorldPos[];
layout(location = 1) perprimitiveEXT out uint vDrawID[];
#endif

layout(set = 1, binding = 0) uniform UBO
{
    mat4 VP;
};

layout(set = 1, binding = 2) uniform UBOViewport
{
    vec4 viewport;
};

#ifndef MESHLET_RENDER_TASK
#error "Must define MESHLET_RENDER_TASK"
#endif

#if MESHLET_RENDER_TASK
taskPayloadSharedEXT CompactedDrawInfo mesh_payload[32 * 32];
#else
layout(set = 0, binding = 10) readonly buffer DrawInfos
{
    CompactedDrawInfo mesh_payload[];
};
#endif

shared vec2 shared_window_positions[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared uint8_t shared_clip_code[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared uvec4 shared_active_vert;
shared uvec4 shared_active_prim;
shared uvec4 shared_active_vert_count;
shared uvec4 shared_active_prim_count;
shared uint shared_active_vert_count_total;
shared uint shared_active_prim_count_total;
shared vec4 shared_clip_positions[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared vec3 shared_positions[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared uint shared_attr_x[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared uint shared_attr_y[MESHLET_PAYLOAD_NUM_CHUNKS * 32];
shared u8vec4 shared_prim_u8[MESHLET_PAYLOAD_NUM_CHUNKS * 32];

const uint CLIP_CODE_INACCURATE = 1 << 0;
const uint CLIP_CODE_NEGATIVE_W = 1 << 1;
const uint CLIP_CODE_NEGATIVE_X = 1 << 2;
const uint CLIP_CODE_NEGATIVE_Y = 1 << 3;
const uint CLIP_CODE_POSITIVE_X = 1 << 4;
const uint CLIP_CODE_POSITIVE_Y = 1 << 5;
const uint CLIP_CODE_PLANES = uint(-1) & ~CLIP_CODE_INACCURATE;

uint compacted_vertex_output(uint index)
{
	return shared_active_vert_count[index / 32u] + bitCount(shared_active_vert[index / 32u] & ((1u << (index & 31u)) - 1u));
}

uint compacted_index_output(uint index)
{
	return shared_active_prim_count[index / 32u] + bitCount(shared_active_prim[index / 32u] & ((1u << (index & 31u)) - 1u));
}

bool lane_has_active_vert(uint index)
{
	return (shared_active_vert[index / 32u] & (1u << (index & 31u))) != 0u;
}

u8vec4 remap_index_buffer(u8vec4 prim_u8)
{
    uvec3 prim = uvec3(prim_u8.xyz);
    return u8vec4(uvec4(compacted_vertex_output(prim.x), compacted_vertex_output(prim.y), compacted_vertex_output(prim.z), 0));
}

bool cull_triangle(vec2 a, vec2 b, vec2 c)
{
	// To be completely accurate, this should be done in fixed point,
	// but we can YOLO a bit since glitches in extreme edge cases are considered okay.
	precise vec2 ab = b - a;
	precise vec2 ac = c - a;

	// This is 100% accurate as long as the primitive is no larger than ~4k subpixels, i.e. 16x16 pixels.
	// Normally, we'd be able to do GEQ test, but GE test is conservative, even with FP error in play.
	precise float pos_area = ab.y * ac.x;
	precise float neg_area = ab.x * ac.y;

    // If the pos value is (-2^24, +2^24), the FP math is exact, if not, we have to be conservative.
    // Less-than check is there to ensure that 1.0 delta in neg_area *will* resolve to a different value.
    bool active_primitive;
	if (abs(pos_area) < 16777216.0)
	    active_primitive = pos_area > neg_area;
    else
	    active_primitive = pos_area >= neg_area;

    if (active_primitive)
    {
        // Micropoly test.
        vec2 lo = floor(ldexp(min(min(a, b), c), ivec2(-8)));
        vec2 hi = floor(ldexp(max(max(a, b), c), ivec2(-8)));
        active_primitive = all(notEqual(lo, hi));
	}

	return active_primitive;
}

void main()
{
    if (gl_LocalInvocationIndex < MESHLET_PAYLOAD_NUM_CHUNKS)
    {
        shared_active_vert[gl_LocalInvocationIndex] = 0;
        shared_active_prim[gl_LocalInvocationIndex] = 0;
    }

    CompactedDrawInfo task = mesh_payload[gl_WorkGroupID.x];
    MeshletMetaRuntime meta = meshlet_metas_runtime.data[task.meshlet_index];
    meshlet_init_workgroup(meta.stream_offset);

	uint linear_index = meshlet_get_linear_index();
    mat4 M = transforms.data[task.node_offset];

    u8vec4 prim_u8;
#define INDEX(index, value) prim_u8 = unpack8(value)
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 0, INDEX);

	vec3 pos;
#define POSITION(index, value) pos = attribute_decode_snorm_exp_position(value)
    MESHLET_DECODE_STREAM_64(meta.stream_offset, 1, POSITION);

	vec3 world_pos = (M * vec4(pos, 1.0)).xyz;
	vec4 clip_pos = VP * vec4(world_pos, 1.0);
	vec2 c = clip_pos.xy / clip_pos.w;

	uint clip_code = clip_pos.w <= 0.0 ? CLIP_CODE_NEGATIVE_W : 0;
	if (any(greaterThan(abs(c), vec2(4.0))))
		clip_code |= CLIP_CODE_INACCURATE;
    if (c.x <= -1.0)
        clip_code |= CLIP_CODE_NEGATIVE_X;
    if (c.y <= -1.0)
        clip_code |= CLIP_CODE_NEGATIVE_Y;
    if (c.x >= 1.0)
        clip_code |= CLIP_CODE_POSITIVE_X;
    if (c.y >= 1.0)
        clip_code |= CLIP_CODE_POSITIVE_Y;

	vec2 window = roundEven(c * viewport.zw + viewport.xy);
	shared_window_positions[linear_index] = window;
	shared_clip_code[linear_index] = uint8_t(clip_code);

    barrier();

	bool is_active_prim = false;
    if (linear_index < meta.num_primitives)
    {
        uvec3 prim = uvec3(prim_u8.xyz);
        uint code_a = shared_clip_code[prim.x];
        uint code_b = shared_clip_code[prim.y];
        uint code_c = shared_clip_code[prim.z];

        uint or_code = code_a | code_b | code_c;
        uint and_code = code_a & code_b & code_c;

        bool culled_planes = (and_code & CLIP_CODE_PLANES) != 0;

        if (!culled_planes)
        {
            bool force_accept = (or_code & (CLIP_CODE_INACCURATE | CLIP_CODE_NEGATIVE_W)) != 0;

            if (!force_accept)
            {
                vec2 a = shared_window_positions[prim.x];
                vec2 b = shared_window_positions[prim.y];
                vec2 c = shared_window_positions[prim.z];
                force_accept = cull_triangle(a, b, c);
            }

            if (force_accept)
            {
				is_active_prim = true;
                atomicOr(shared_active_prim[linear_index / 32], 1u << (linear_index & 31));
                atomicOr(shared_active_vert[prim.x / 32], 1u << (prim.x & 31));
                atomicOr(shared_active_vert[prim.y / 32], 1u << (prim.y & 31));
                atomicOr(shared_active_vert[prim.z / 32], 1u << (prim.z & 31));
            }
        }
    }

    barrier();

    if (gl_LocalInvocationIndex == 0)
    {
		uvec3 num_active_prim = bitCount(shared_active_prim.xyz);
		num_active_prim.y += num_active_prim.x;
		num_active_prim.z += num_active_prim.y;
		shared_active_prim_count = uvec4(0, num_active_prim);

		uvec3 num_active_vert = bitCount(shared_active_vert.xyz);
		num_active_vert.y += num_active_vert.x;
		num_active_vert.z += num_active_vert.y;
		shared_active_vert_count = uvec4(0, num_active_vert);

		shared_active_prim_count_total = num_active_prim.z + bitCount(shared_active_prim.w);
		shared_active_vert_count_total = num_active_vert.z + bitCount(shared_active_vert.w);
	}

    barrier();

	uint num_verts = shared_active_vert_count_total;
	uint num_prims = shared_active_prim_count_total;

    SetMeshOutputsEXT(num_verts, num_prims);

	if (is_active_prim)
		shared_prim_u8[compacted_index_output(linear_index)] = remap_index_buffer(prim_u8);

	bool has_active_vert = lane_has_active_vert(linear_index);

	if (has_active_vert)
	{
        uint out_vert_index = compacted_vertex_output(linear_index);
        shared_positions[out_vert_index] = world_pos;
        shared_clip_positions[out_vert_index] = clip_pos;
	}

	barrier();

    if (gl_LocalInvocationIndex < num_prims)
    {
        gl_PrimitiveTriangleIndicesEXT[gl_LocalInvocationIndex] = uvec3(shared_prim_u8[gl_LocalInvocationIndex].xyz);
        vDrawID[gl_LocalInvocationIndex] = task.meshlet_index;
    }

	if (gl_LocalInvocationIndex < num_verts)
	{
		gl_MeshVerticesEXT[gl_LocalInvocationIndex].gl_Position = shared_clip_positions[gl_LocalInvocationIndex];
		vWorldPos[gl_LocalInvocationIndex] = shared_positions[gl_LocalInvocationIndex];
    }

#if 0
#define NORMAL(index, value) \
    if (index < meta.num_attributes) \
    { \
        vNormal[index] = mat3(M) * attribute_decode_oct8_normal_tangent(value).xyz; \
    }
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 3, NORMAL);

#define TANGENT(index, value) \
    if (index < meta.num_attributes) \
    { \
        mediump vec4 T = attribute_decode_oct8_normal_tangent(value); \
        vTangent[index] = vec4(mat3(M) * T.xyz, T.w); \
    }
    MESHLET_DECODE_STREAM_32(meta.stream_offset, 4, TANGENT);

#define UV(index, value) \
    if (index < meta.num_attributes) \
    { \
        vUV[index] = attribute_decode_snorm_exp_uv(value); \
    }
    MESHLET_DECODE_STREAM_64(meta.stream_offset, 5, UV);
#endif
}
