#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_shuffle : require
layout(local_size_x = 32) in;

#define MESHLET_RENDER_DESCRIPTOR_SET 0
#define MESHLET_RENDER_AABB_BINDING 0
#define MESHLET_RENDER_TRANSFORM_BINDING 1
#define MESHLET_RENDER_TASKS_BINDING 2
#define MESHLET_RENDER_BOUND_BINDING 7
#define MESHLET_RENDER_FRUSTUM_BINDING 8
#include "meshlet_render.h"

layout(push_constant, std430) uniform Registers
{
    vec3 camera_pos;
    uint count;
} registers;

struct MeshTask
{
    uint meshlet_index;
    uint node_instance;
    uint node_count_material_index;
};

struct Payload
{
    MeshTask meshlets[32 * 32];
};
taskPayloadSharedEXT Payload mesh_payload;

layout(set = 0, binding = 9) buffer Counter { uint task_counter; };

void main()
{
    TaskInfo task;
    uint task_index = gl_GlobalInvocationID.x;

    bool task_needs_work = false;
    if (task_index < registers.count)
    {
        task = task_info.data[task_index];

        // Precull the group.
        AABB aabb = aabb.data[task.aabb_instance];
        task_needs_work = frustum_cull(aabb.lo, aabb.hi);
    }

    uint b = subgroupBallot(task_needs_work).x;

    uint payload_offset = 0;
    while (b != 0)
    {
        int lane = findLSB(b);
        b &= ~(1u << lane);

        uint node_instance = subgroupShuffle(task.node_instance, lane);
        uint node_count_material_index = subgroupShuffle(task.node_count_material_index, lane);
        uint mesh_index_count = subgroupShuffle(task.mesh_index_count, lane);

        uint offset = mesh_index_count & ~31u;
        uint count = bitfieldExtract(mesh_index_count, 0, 5) + 1;

        uint meshlet_index = offset + gl_SubgroupInvocationID;

        bool alloc_draw = false;
        if (gl_SubgroupInvocationID < count)
        {
            mat4 M = transforms.data[node_instance];
            Bound b = bounds.data[meshlet_index];
            alloc_draw = cluster_cull(M, b, registers.camera_pos);
        }

        uvec4 ballot = subgroupBallot(alloc_draw);
        uint draw_count = subgroupBallotBitCount(ballot);
        uint local_offset = subgroupBallotExclusiveBitCount(ballot);

        if (alloc_draw)
        {
            mesh_payload.meshlets[payload_offset + local_offset] =
                MeshTask(meshlet_index, node_instance, node_count_material_index);
        }

        payload_offset += draw_count;
    }

    if (gl_LocalInvocationIndex == 0)
        atomicAdd(task_counter, payload_offset);

    EmitMeshTasksEXT(payload_offset, 1, 1);
}