#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_scalar_block_layout : require

#ifndef MESHLET_SIZE
#error "Must define MESHLET_SIZE"
#endif

layout(max_primitives = MESHLET_SIZE, max_vertices = MESHLET_SIZE, triangles) out;
layout(local_size_x = 32, local_size_y_id = 0) in;

#include "meshlet_render_types.h"
#include "meshlet_primitive_cull.h"

layout(location = 0) out vec3 vWorldPos[];
layout(location = 1) perprimitiveEXT out uint vDrawID[];

layout(set = 1, binding = 0) uniform UBO
{
    mat4 VP;
};

layout(set = 1, binding = 2) uniform UBOViewport
{
    vec4 viewport;
};

layout(set = 0, binding = 0, scalar) readonly buffer IBO
{
    u8vec3 data[];
} ibo;

layout(set = 0, binding = 1, scalar) readonly buffer VBOPOS
{
    vec3 data[];
} pos;

layout(set = 0, binding = 3, std430) readonly buffer IndirectCommands
{
    IndirectDrawMesh draws[];
} indirect_commands_mesh;

#ifdef MESHLET_RENDER_TASK_HIERARCHICAL
taskPayloadSharedEXT CompactedDrawInfoPayload mesh_payload;
#else
layout(set = 0, binding = 4, std430) readonly buffer CompactedDraws
{
    CompactedDrawInfo infos[];
} mesh_payload;
#endif

layout(set = 0, binding = 5, std430) readonly buffer Transforms
{
    mat4 data[];
} transforms;

void main()
{
    uint linear_index = gl_LocalInvocationIndex;
    uint compacted_meshlet_index = meshlet_get_meshlet_index();
    uint base_chunk_index = meshlet_get_base_chunk_index();

#if defined(MESHLET_RENDER_TASK_HIERARCHICAL) && !MESHLET_RENDER_TASK_HIERARCHICAL
    CompactedDrawInfo task = mesh_payload.info;
    task.meshlet_index += uint(mesh_payload.offsets[compacted_meshlet_index]);
#else
    CompactedDrawInfo task = mesh_payload.infos[compacted_meshlet_index];
#endif

    IndirectDrawMesh meshlet = indirect_commands_mesh.draws[task.meshlet_index];
    mat4 M = transforms.data[task.node_offset];

    // Transform positions.
    vec3 pos = pos.data[meshlet.vertex_offset + linear_index + 32u * base_chunk_index];
    vec3 world_pos = (M * vec4(pos, 1.0)).xyz;
    vec4 clip_pos = VP * vec4(world_pos, 1.0);

    meshlet_setup_local_invocation(gl_LocalInvocationID.xy);

    meshlet_emit_clip_pos(clip_pos, viewport);

    uvec3 prim = uvec3(ibo.data[meshlet.primitive_offset + linear_index + 32u * base_chunk_index]);
    meshlet_emit_primitive(prim);

    if (linear_index < shared_active_prim_count_total)
        vDrawID[linear_index] = task.meshlet_index;

    if (meshlet_lane_has_active_vert())
    {
        uint out_vert_index = meshlet_compacted_vertex_output();
        gl_MeshVerticesEXT[out_vert_index].gl_Position = clip_pos;
        vWorldPos[out_vert_index] = world_pos;
    }
}
