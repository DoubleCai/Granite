#version 450
#extension GL_EXT_scalar_block_layout : require

layout(local_size_x = 32) in;

#define MESHLET_RENDER_DESCRIPTOR_SET 0
#define MESHLET_RENDER_BOUND_BINDING 6
#define MESHLET_RENDER_AABB_BINDING 0
#define MESHLET_RENDER_TRANSFORM_BINDING 1
#define MESHLET_RENDER_FRUSTUM_BINDING 7
#define MESHLET_RENDER_TASKS_BINDING 2
#include "meshlet_render.h"

layout(constant_id = 0) const int MESHLET_RENDER_DRAW_WORDS = 0;
layout(constant_id = 1) const int MESHLET_APPEND_ATOMIC_INDEX = 0;

layout(set = 0, binding = 3, std430) readonly buffer InputDraws
{
    uint draws[];
} input_draws;

layout(set = 0, binding = 4, std430) writeonly buffer OutputDraws
{
    uint count[3];
    layout(offset = 256) uint draws[];
} output_draws;

layout(set = 0, binding = 5, std430) writeonly buffer CompactedDraws
{
    CompactedDrawInfo data[];
} output_draw_info;

layout(push_constant, std430) uniform Registers
{
    vec3 camera_pos;
    uint count;
} registers;

shared uint ballot_value;
shared uint global_offset;

uvec4 ballot(bool v)
{
    barrier();
    if (gl_LocalInvocationIndex == 0)
        ballot_value = 0;
    barrier();
    if (v)
        atomicOr(ballot_value, 1u << gl_LocalInvocationIndex);
    barrier();
    return uvec4(ballot_value, 0, 0, 0);
}

uint ballotBitCount(uvec4 v)
{
    return bitCount(v.x);
}

uint ballotExclusiveBitCount(uvec4 v)
{
    uint mask = (1u << gl_LocalInvocationIndex) - 1u;
    return bitCount(v.x & mask);
}
#define local_invocation_id gl_LocalInvocationIndex

void main()
{
    TaskInfo task;
    uint task_index = gl_WorkGroupID.x * gl_WorkGroupSize.x + local_invocation_id;
    bool task_needs_work = false;
    if (task_index < registers.count)
    {
        task = task_info.data[task_index];

        // Precull the group.
        AABB aabb = aabb.data[task.aabb_instance];
        task_needs_work = frustum_cull(aabb.lo, aabb.hi);
    }

    uint b = ballot(task_needs_work).x;

    while (b != 0)
    {
        int lane = findLSB(b);
        b &= ~(1u << lane);

        TaskInfo tmp_task = task_info.data[gl_WorkGroupID.x * gl_WorkGroupSize.x + lane];
        uint node_instance = tmp_task.node_instance;
        uint node_count_material_index = tmp_task.node_count_material_index;
        uint mesh_index_count = tmp_task.mesh_index_count;

        uint offset = mesh_index_count & ~31u;
        uint count = bitfieldExtract(mesh_index_count, 0, 5) + 1;

        uint meshlet_index = offset + local_invocation_id;

        bool alloc_draw = false;
        if (local_invocation_id < count)
        {
            mat4 M = transforms.data[node_instance];
            Bound b = bounds.data[meshlet_index];
            alloc_draw = cluster_cull(M, b, registers.camera_pos);
        }

        uvec4 ballot = ballot(alloc_draw);
        uint draw_count = ballotBitCount(ballot);
        uint local_offset = ballotExclusiveBitCount(ballot);

        // WAR barrier is implied here in earlier ballot.
        if (gl_LocalInvocationIndex == 0)
            global_offset = atomicAdd(output_draws.count[MESHLET_APPEND_ATOMIC_INDEX], draw_count);
        barrier();

        if (alloc_draw)
        {
			uint dst_offset = MESHLET_RENDER_DRAW_WORDS * (global_offset + local_offset);
			uint src_offset = meshlet_index * MESHLET_RENDER_DRAW_WORDS;
			for (int i = 0; i < MESHLET_RENDER_DRAW_WORDS; i++)
				output_draws.draws[dst_offset + i] = input_draws.draws[src_offset + i];

            output_draw_info.data[global_offset + local_offset] =
				CompactedDrawInfo(meshlet_index, node_instance, node_count_material_index);
        }
    }
}
