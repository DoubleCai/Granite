#version 450
#extension GL_EXT_scalar_block_layout : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_shuffle : require

#include "debug_channel.h"

layout(local_size_x = 32) in;

#define MESHLET_RENDER_DESCRIPTOR_SET 0
#define MESHLET_RENDER_GROUP_BOUND_BINDING 6
#define MESHLET_RENDER_AABB_BINDING 0
#define MESHLET_RENDER_TRANSFORM_BINDING 1
#define MESHLET_RENDER_FRUSTUM_BINDING 7
#define MESHLET_RENDER_TASKS_BINDING 2
#include "meshlet_render.h"

struct Draw
{
    uint payload[5];
};

layout(set = 0, binding = 3, std430) readonly buffer InputDraws
{
    Draw data[];
} input_draws;

layout(set = 0, binding = 4, std430) writeonly buffer OutputDraws
{
    uint count;
    uint padding[256 / 4 - 1];
    Draw data[];
} output_draws;

layout(set = 0, binding = 5, scalar) writeonly buffer CompactedDraws
{
    uvec3 data[];
} output_draw_info;

layout(push_constant, std430) uniform Registers
{
    vec3 camera_pos;
    uint count;
} registers;

void main()
{
    TaskInfo task;
    uint task_index = gl_GlobalInvocationID.x;
    bool task_needs_work = false;
    if (task_index < registers.count)
    {
        task = task_info.data[task_index];

        // Precull the group.
        mat4 M = transforms.data[task.node_instance];
        vec3 lo = group_bounds.data[task.cluster_group_index].lo;
        vec3 hi = group_bounds.data[task.cluster_group_index].hi;
        transform_aabb(M, lo, hi);

        task_needs_work = frustum_cull(lo, hi);
    }

    uint b = subgroupBallot(task_needs_work).x;

    while (b != 0)
    {
        int lane = findLSB(b);
        b &= ~(1u << lane);

        uint cluster_group_index = subgroupShuffle(task.cluster_group_index, lane);
        uint node_instance = subgroupShuffle(task.node_instance, lane);
        uint node_count_material_index = subgroupShuffle(task.node_count_material_index, lane);
        uint mesh_index_count = subgroupShuffle(task.mesh_index_count, lane);

        uint offset = mesh_index_count & ~31u;
        uint count = bitfieldExtract(mesh_index_count, 0, 5) + 1;

        bool alloc_draw = false;
        if (gl_SubgroupInvocationID < count)
        {
            mat4 M = transforms.data[node_instance];
            Bound b = group_bounds.data[cluster_group_index].bounds[gl_SubgroupInvocationID];
            alloc_draw = cluster_cull(M, b, registers.camera_pos);
        }

        uvec4 ballot = subgroupBallot(alloc_draw);
        uint draw_count = subgroupBallotBitCount(ballot);
        uint local_offset = subgroupBallotExclusiveBitCount(ballot);

        uint global_offset;
        if (subgroupElect())
            global_offset = atomicAdd(output_draws.count, draw_count);
        global_offset = subgroupBroadcastFirst(global_offset);

        if (alloc_draw)
        {
            output_draws.data[global_offset + local_offset] = input_draws.data[offset + gl_SubgroupInvocationID];
            output_draw_info.data[global_offset + local_offset] = uvec3(node_instance, node_count_material_index, offset + gl_GlobalInvocationID);
        }
    }
}