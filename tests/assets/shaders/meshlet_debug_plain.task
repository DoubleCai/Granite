#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_ballot : require

layout(local_size_x = 32) in;

#define MESHLET_RENDER_DESCRIPTOR_SET 0
#define MESHLET_RENDER_TRANSFORM_BINDING 4
#define MESHLET_RENDER_AABB_BINDING 5
#define MESHLET_RENDER_TASKS_BINDING 6
#define MESHLET_RENDER_BOUND_BINDING 7
#define MESHLET_RENDER_FRUSTUM_BINDING 8
#include "meshlet_render.h"

layout(push_constant, std430) uniform Registers
{
    vec3 camera_pos;
    uint offset;
} registers;

struct TaskPayload
{
	CompactedDrawInfo info;
	uint8_t indices[32];
};

taskPayloadSharedEXT TaskPayload mesh_payload;

void main()
{
    uint task_index = gl_WorkGroupID.x + registers.offset;
	TaskInfo task = task_info.data[task_index];

	// Precull the group.
	uint offset = task.mesh_index_count & ~31u;
	uint count = bitfieldExtract(task.mesh_index_count, 0, 5) + 1;
	uint meshlet_index = offset + gl_SubgroupInvocationID;

	if (gl_SubgroupInvocationID == 0)
	{
		mesh_payload.info =
			CompactedDrawInfo(offset, task.node_instance, task.node_count_material_index);
	}

    bool alloc_draw = false;
	if (gl_SubgroupInvocationID < count)
	{
		mat4 M = transforms.data[task.node_instance];
		Bound b = bounds.data[meshlet_index];
		alloc_draw = cluster_cull(M, b, registers.camera_pos);
	}

	uvec4 ballot = subgroupBallot(alloc_draw);
	uint draw_count = subgroupBallotBitCount(ballot);
	uint local_offset = subgroupBallotExclusiveBitCount(ballot);

	if (alloc_draw)
		mesh_payload.indices[local_offset] = uint8_t(gl_SubgroupInvocationID);

    EmitMeshTasksEXT(draw_count, 1, 1);
}
