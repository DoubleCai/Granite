#version 450
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_KHR_shader_subgroup_basic : require

layout(local_size_x = 64) in;
layout(constant_id = 0) const bool DOWNSCALING = false;

layout(set = 0, binding = 0) uniform mediump texture2D uTexture;
layout(set = 0, binding = 1) writeonly uniform mediump image2D uOutput;
#if PLANES >= 2
layout(set = 0, binding = 2) writeonly uniform mediump image2D uChromaPlane2;
#endif
#if PLANES >= 3
layout(set = 0, binding = 3) writeonly uniform mediump image2D uChromaPlane3;
#endif

// Downscaling requires more aggressive filtering, and ensures that everything is POT.
const int INPUT_WIDTH = DOWNSCALING ? 16 : 8;
const int INPUT_HEIGHT = DOWNSCALING ? 16 : 8;
const int APRON = 4;

const int PADDED_INPUT_WIDTH = INPUT_WIDTH + 2 * APRON;
const int PADDED_INPUT_HEIGHT = INPUT_HEIGHT + 2 * APRON;
const int OUTPUT_WIDTH = 8;
const int OUTPUT_HEIGHT = 8;

const int TAPS_HALF = APRON;
const int TAPS = APRON * 2;
const int PHASES_BITS = 8;
const int PHASES = 1 << PHASES_BITS;

layout(set = 0, binding = 4, std430) readonly buffer Weights
{
    f16vec2 weights[];
};

ivec2 unswizzle8x8(uint index)
{
    uint y = bitfieldExtract(index, 0, 1);
    uint x = bitfieldExtract(index, 1, 2);
    y |= bitfieldExtract(index, 3, 2) << 1;
    x |= bitfieldExtract(index, 5, 1) << 2;
    return ivec2(x, y);
}

shared f16vec2 shared_rg[PADDED_INPUT_HEIGHT][PADDED_INPUT_WIDTH + 1];
shared f16vec2 shared_ba[PADDED_INPUT_HEIGHT][PADDED_INPUT_WIDTH + 1];
shared f16vec2 shared_horiz_weights[OUTPUT_WIDTH][TAPS_HALF + 1];
shared f16vec2 shared_vert_weights[OUTPUT_HEIGHT][TAPS_HALF + 1];

layout(push_constant) uniform Registers
{
    ivec2 resolution;
    vec2 scaling_to_input;
} registers;

void main()
{
    int local_index = int(gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID);

    ivec2 base_output = ivec2(gl_WorkGroupID.xy) * ivec2(OUTPUT_WIDTH, OUTPUT_HEIGHT);
    precise vec2 base_input = (vec2(base_output) + 0.5) * registers.scaling_to_input - 0.5;

    ivec2 unswizzle_coord = unswizzle8x8(local_index);
    ivec2 local_coord = ivec2(floor(base_input)) + unswizzle_coord - (APRON - 1);

    for (int y = 0; y < PADDED_INPUT_HEIGHT; y += OUTPUT_HEIGHT)
    {
        for (int x = 0; x < PADDED_INPUT_WIDTH; x += OUTPUT_WIDTH)
        {
            ivec2 coord = local_coord + ivec2(x, y);
            // TODO: Make it configurable whether to clamp or not?
            // TODO: Use implicit first-stage low quality downsample with texture sample as alternative path.
            coord = clamp(coord, ivec2(0), registers.resolution - 1);
            f16vec4 rgb = f16vec4(texelFetch(uTexture, coord, 0));
            shared_rg[y + unswizzle_coord.y][x + unswizzle_coord.x] = rgb.rg;
            shared_ba[y + unswizzle_coord.y][x + unswizzle_coord.x] = rgb.ba;
        }
    }

    // Load vertical filter weights.
    for (int phase_index = local_index / TAPS_HALF;
        phase_index < OUTPUT_HEIGHT;
        phase_index += int(gl_WorkGroupSize.x / TAPS_HALF))
    {
        precise int shared_coord =
            int(float(PHASES) * (base_input.y + registers.scaling_to_input.y * float(phase_index)) + 0.5);
        int shared_phase = int(bitfieldExtract(uint(shared_coord), 0, PHASES_BITS));
        int tap = local_index & (TAPS_HALF - 1);
        shared_vert_weights[phase_index][tap] = weights[TAPS_HALF * PHASES + shared_phase * TAPS_HALF + tap];
    }

    // Load horizontal filter weights.
    for (int phase_index = local_index / TAPS_HALF;
        phase_index < OUTPUT_WIDTH;
        phase_index += int(gl_WorkGroupSize.x / TAPS_HALF))
    {
        precise int shared_coord =
            int(float(PHASES) * (base_input.x + registers.scaling_to_input.x * float(phase_index)) + 0.5);
        int shared_phase = int(bitfieldExtract(uint(shared_coord), 0, PHASES_BITS));
        int tap = local_index & (TAPS_HALF - 1);
        shared_horiz_weights[phase_index][tap] = weights[shared_phase * TAPS_HALF + tap];
    }

    barrier();

    const int NUM_HORIZONTAL_PIXELS_PER_ITERATION = int(gl_WorkGroupSize.x) / OUTPUT_HEIGHT;
    const int NUM_HORIZONTAL_ITERATIONS = PADDED_INPUT_WIDTH / NUM_HORIZONTAL_PIXELS_PER_ITERATION;
    f16vec4 result[NUM_HORIZONTAL_ITERATIONS];

    for (int iter = 0; iter < NUM_HORIZONTAL_ITERATIONS; iter++)
    {
        // Filter vertically.
        f16vec4 tmp = f16vec4(0.0);

        int off_x = int(local_index) / OUTPUT_HEIGHT + NUM_HORIZONTAL_PIXELS_PER_ITERATION * iter;
        int off_y = int(local_index) % OUTPUT_HEIGHT;

        precise int shared_coord_y =
            int(float(PHASES) * (base_input.y + registers.scaling_to_input.y * float(off_y)) + 0.5);
        shared_coord_y >>= PHASES_BITS;
        shared_coord_y -= int(base_input.y);

        for (int i = 0; i < TAPS_HALF; i++)
        {
            f16vec2 w = shared_vert_weights[off_y][i];
            f16vec2 rg0 = shared_rg[shared_coord_y + 2 * i + 0][off_x];
            f16vec2 rg1 = shared_rg[shared_coord_y + 2 * i + 1][off_x];
            f16vec2 ba0 = shared_ba[shared_coord_y + 2 * i + 0][off_x];
            f16vec2 ba1 = shared_ba[shared_coord_y + 2 * i + 1][off_x];
            tmp += f16vec4(rg0, ba0) * w.x + f16vec4(rg1, ba1) * w.y;
        }

        result[iter] = tmp;
    }

    barrier();

    for (int iter = 0; iter < NUM_HORIZONTAL_ITERATIONS; iter++)
    {
        int off_x = int(local_index) / OUTPUT_HEIGHT + NUM_HORIZONTAL_PIXELS_PER_ITERATION * iter;
        int off_y = int(local_index) % OUTPUT_HEIGHT;
        shared_rg[off_y][off_x] = result[iter].rg;
        shared_ba[off_y][off_x] = result[iter].ba;
    }

    barrier();

    // Filter horizontally.
    f16vec4 tmp = f16vec4(0.0);

    precise int shared_coord_x =
        int(float(PHASES) * (base_input.x + registers.scaling_to_input.x * float(unswizzle_coord.x)) + 0.5);
    shared_coord_x >>= PHASES_BITS;
    shared_coord_x -= int(base_input.x);

    for (int i = 0; i < TAPS_HALF; i++)
    {
        f16vec2 w = shared_horiz_weights[unswizzle_coord.x][i];
        f16vec2 rg0 = shared_rg[unswizzle_coord.y][shared_coord_x + 2 * i + 0];
        f16vec2 rg1 = shared_rg[unswizzle_coord.y][shared_coord_x + 2 * i + 1];
        f16vec2 ba0 = shared_ba[unswizzle_coord.y][shared_coord_x + 2 * i + 0];
        f16vec2 ba1 = shared_ba[unswizzle_coord.y][shared_coord_x + 2 * i + 1];
        tmp += f16vec4(rg0, ba0) * w.x + f16vec4(rg1, ba1) * w.y;
    }

    imageStore(uOutput, base_output + unswizzle_coord, tmp);
}