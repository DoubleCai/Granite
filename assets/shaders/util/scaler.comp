#version 450
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_KHR_shader_subgroup_basic : require

layout(local_size_x = 64) in;
layout(constant_id = 0) const bool DOWNSCALING = false;

layout(set = 0, binding = 0) uniform mediump texture2D uTexture;
layout(set = 0, binding = 1) writeonly uniform mediump image2D uOutput;
#if PLANES >= 2
layout(set = 0, binding = 2) writeonly uniform mediump image2D uChromaPlane2;
#endif
#if PLANES >= 3
layout(set = 0, binding = 3) writeonly uniform mediump image2D uChromaPlane3;
#endif

// Downscaling requires more aggressive filtering, and ensures that everything is POT.
const int INPUT_WIDTH = DOWNSCALING ? 16 : 8;
const int INPUT_HEIGHT = DOWNSCALING ? 16 : 8;
const int APRON = 4;

const int PADDED_INPUT_WIDTH = INPUT_WIDTH + 2 * APRON;
const int PADDED_INPUT_HEIGHT = INPUT_HEIGHT + 2 * APRON;
const int OUTPUT_WIDTH = 8;
const int OUTPUT_HEIGHT = 8;

const int TAPS = APRON * 2;
const int PHASES_BITS = 8;
const int PHASES = 1 << PHASES_BITS;

layout(set = 0, binding = 4, std430) readonly buffer Weights
{
    float weights[];
};

ivec2 unswizzle8x8(uint index)
{
    uint y = bitfieldExtract(index, 0, 1);
    uint x = bitfieldExtract(index, 1, 2);
    y |= bitfieldExtract(index, 3, 2) << 1;
    x |= bitfieldExtract(index, 5, 1) << 2;
    return ivec2(x, y);
}

shared float shared_r[PADDED_INPUT_HEIGHT][PADDED_INPUT_WIDTH];
shared float shared_g[PADDED_INPUT_HEIGHT][PADDED_INPUT_WIDTH];
shared float shared_b[PADDED_INPUT_HEIGHT][PADDED_INPUT_WIDTH];

shared float shared_horiz_weights[OUTPUT_WIDTH][TAPS];
shared float shared_vert_weights[OUTPUT_HEIGHT][TAPS];

layout(push_constant) uniform Registers
{
    ivec2 resolution;
    vec2 scaling_to_input;
} registers;

void main()
{
    int local_index = int(gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID);

    ivec2 base_output = ivec2(gl_WorkGroupID.xy) * ivec2(OUTPUT_WIDTH, OUTPUT_HEIGHT);
    precise vec2 base_input = (vec2(base_output) + 0.5) * registers.scaling_to_input - 0.5;

    ivec2 unswizzle_coord = unswizzle8x8(local_index);
    ivec2 local_coord = ivec2(floor(base_input)) + unswizzle_coord - (APRON - 1);

    for (int y = 0; y < PADDED_INPUT_HEIGHT; y += OUTPUT_HEIGHT)
    {
        for (int x = 0; x < PADDED_INPUT_WIDTH; x += OUTPUT_WIDTH)
        {
            ivec2 coord = local_coord + ivec2(x, y);
            // TODO: Make it configurable whether to clamp or not?
            // TODO: Use implicit first-stage low quality downsample with texture sample as alternative path.
            coord = clamp(coord, ivec2(0), registers.resolution - 1);
            vec3 rgb = texelFetch(uTexture, coord, 0).rgb;

            shared_r[y + unswizzle_coord.y][x + unswizzle_coord.x] = rgb.r;
            shared_g[y + unswizzle_coord.y][x + unswizzle_coord.x] = rgb.g;
            shared_b[y + unswizzle_coord.y][x + unswizzle_coord.x] = rgb.b;
        }
    }

    // Load vertical filter weights.
    for (int phase_index = local_index / TAPS;
        phase_index < OUTPUT_HEIGHT;
        phase_index += int(gl_WorkGroupSize.x / TAPS))
    {
        precise int shared_coord =
            int(float(PHASES) * (base_input.y + registers.scaling_to_input.y * float(phase_index)) + 0.5);
        int shared_phase = int(bitfieldExtract(uint(shared_coord), 0, PHASES_BITS));
        int tap = local_index & (TAPS - 1);
        shared_vert_weights[phase_index][tap] = weights[TAPS * PHASES + shared_phase * TAPS + tap];
    }

    // Load horizontal filter weights.
    for (int phase_index = local_index / TAPS;
        phase_index < OUTPUT_WIDTH;
        phase_index += int(gl_WorkGroupSize.x / TAPS))
    {
        precise int shared_coord =
            int(float(PHASES) * (base_input.x + registers.scaling_to_input.x * float(phase_index)) + 0.5);
        int shared_phase = int(bitfieldExtract(uint(shared_coord), 0, PHASES_BITS));
        int tap = local_index & (TAPS - 1);
        shared_horiz_weights[phase_index][tap] = weights[shared_phase * TAPS + tap];
    }

    barrier();

    const int NUM_HORIZONTAL_PIXELS_PER_ITERATION = int(gl_WorkGroupSize.x) / OUTPUT_HEIGHT;
    const int NUM_HORIZONTAL_ITERATIONS = PADDED_INPUT_WIDTH / NUM_HORIZONTAL_PIXELS_PER_ITERATION;
    vec3 result[NUM_HORIZONTAL_ITERATIONS];

    for (int iter = 0; iter < NUM_HORIZONTAL_ITERATIONS; iter++)
    {
        // Filter vertically.
        vec3 tmp = vec3(0.0);

        int off_x = int(local_index) / OUTPUT_HEIGHT + NUM_HORIZONTAL_PIXELS_PER_ITERATION * iter;
        int off_y = int(local_index) % OUTPUT_HEIGHT;

        precise int shared_coord_y =
            int(float(PHASES) * (base_input.y + registers.scaling_to_input.y * float(off_y)) + 0.5);
        shared_coord_y >>= PHASES_BITS;
        shared_coord_y -= int(base_input.y);

        for (int i = 0; i < TAPS; i++)
        {
            float w = shared_vert_weights[off_y][i];
            //float w = i == 3 ? 1.0 : 0.0;
            float r = shared_r[shared_coord_y + i][off_x];
            float g = shared_g[shared_coord_y + i][off_x];
            float b = shared_b[shared_coord_y + i][off_x];
            tmp += vec3(r, g, b) * w;
        }

        result[iter] = tmp;
    }

    barrier();

    for (int iter = 0; iter < NUM_HORIZONTAL_ITERATIONS; iter++)
    {
        int off_x = int(local_index) / OUTPUT_HEIGHT + NUM_HORIZONTAL_PIXELS_PER_ITERATION * iter;
        int off_y = int(local_index) % OUTPUT_HEIGHT;
        shared_r[off_y][off_x] = result[iter].r;
        shared_g[off_y][off_x] = result[iter].g;
        shared_b[off_y][off_x] = result[iter].b;
    }

    barrier();

    // Filter horizontally.
    vec3 tmp = vec3(0.0);

    #if 1
    precise int shared_coord_x =
        int(float(PHASES) * (base_input.x + registers.scaling_to_input.x * float(unswizzle_coord.x)) + 0.5);
    shared_coord_x >>= PHASES_BITS;
    shared_coord_x -= int(base_input.x);

    for (int i = 0; i < TAPS; i++)
    {
        float w = shared_horiz_weights[unswizzle_coord.x][i];
        float r = shared_r[unswizzle_coord.y][shared_coord_x + i];
        float g = shared_g[unswizzle_coord.y][shared_coord_x + i];
        float b = shared_b[unswizzle_coord.y][shared_coord_x + i];
        tmp += vec3(r, g, b) * w;
    }
    #endif

    imageStore(uOutput, base_output + unswizzle_coord, vec4(tmp, 1.0));
}