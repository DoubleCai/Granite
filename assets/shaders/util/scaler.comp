#version 450
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_KHR_shader_subgroup_basic : require

layout(local_size_x = 64) in;
layout(constant_id = 0) const bool DOWNSCALING = false;
layout(constant_id = 1) const bool SAMPLED_DOWNSCALING = false;
layout(constant_id = 2) const bool CLAMP_COORD = false;

layout(set = 0, binding = 0) uniform mediump texture2D uTexture;
layout(set = 0, binding = 1) writeonly uniform mediump image2D uOutput;
#if PLANES >= 2
layout(set = 0, binding = 2) writeonly uniform mediump image2D uChromaPlane2;
#endif
#if PLANES >= 3
layout(set = 0, binding = 3) writeonly uniform mediump image2D uChromaPlane3;
#endif

layout(set = 0, binding = 5) uniform sampler uLinearSampler;

// Downscaling requires more aggressive filtering, and ensures that everything is POT.
const int INPUT_WIDTH = DOWNSCALING ? 16 : 8;
const int INPUT_HEIGHT = DOWNSCALING ? 16 : 8;
const int APRON = 4;

const int PADDED_INPUT_WIDTH = INPUT_WIDTH + 2 * APRON;
const int PADDED_INPUT_HEIGHT = INPUT_HEIGHT + 2 * APRON;
const int OUTPUT_WIDTH = 8;
const int OUTPUT_HEIGHT = 8;

const int TAPS_HALF = APRON;
const int TAPS = APRON * 2;
const int PHASES_BITS = 8;
const int PHASES = 1 << PHASES_BITS;

layout(set = 0, binding = 4, std430) readonly buffer Weights
{
    f16vec2 weights[];
};

ivec2 unswizzle8x8(uint index)
{
    uint y = bitfieldExtract(index, 0, 1);
    uint x = bitfieldExtract(index, 1, 2);
    y |= bitfieldExtract(index, 3, 2) << 1;
    x |= bitfieldExtract(index, 5, 1) << 2;
    return ivec2(x, y);
}

shared f16vec2 shared_rg[PADDED_INPUT_HEIGHT][PADDED_INPUT_WIDTH + 1];
shared f16vec2 shared_ba[PADDED_INPUT_HEIGHT][PADDED_INPUT_WIDTH + 1];

layout(push_constant) uniform Registers
{
    ivec2 resolution;
    vec2 scaling_to_input;
    vec2 inv_input_resolution;
} registers;

void main()
{
    int local_index = int(gl_SubgroupID * gl_SubgroupSize + gl_SubgroupInvocationID);

    ivec2 base_output = ivec2(gl_WorkGroupID.xy) * ivec2(OUTPUT_WIDTH, OUTPUT_HEIGHT);
    precise vec2 base_input = (vec2(base_output) + 0.5) * registers.scaling_to_input - 0.5;

    ivec2 unswizzle_coord = unswizzle8x8(local_index);
    ivec2 local_coord = ivec2(floor(base_input)) + unswizzle_coord - (APRON - 1);

    for (int y = 0; y < PADDED_INPUT_HEIGHT; y += OUTPUT_HEIGHT)
    {
        for (int x = 0; x < PADDED_INPUT_WIDTH; x += OUTPUT_WIDTH)
        {
            ivec2 coord = local_coord + ivec2(x, y);

            f16vec4 rgba;

            if (SAMPLED_DOWNSCALING)
            {
                // For very high downsampling ratios, pre-filter to double target resolution first.
                // This should retain most interesting frequencies at half-nyquist.
                // For extreme downsampling ratios, can just run the filter multiple times
                // (but there's no reasonable use case for that for me).
                vec2 uv = (vec2(coord) + 0.5) * registers.inv_input_resolution;
                rgba = f16vec4(textureLod(sampler2D(uTexture, uLinearSampler), uv, 0.0));
            }
            else
            {
                if (CLAMP_COORD)
                    coord = clamp(coord, ivec2(0), registers.resolution - 1);
                rgba = f16vec4(texelFetch(uTexture, coord, 0));
            }

            shared_rg[y + unswizzle_coord.y][x + unswizzle_coord.x] = rgba.rg;
            shared_ba[y + unswizzle_coord.y][x + unswizzle_coord.x] = rgba.ba;
        }
    }

    barrier();

    const int NUM_HORIZONTAL_PIXELS_PER_ITERATION = int(gl_WorkGroupSize.x) / OUTPUT_HEIGHT;
    const int NUM_HORIZONTAL_ITERATIONS = PADDED_INPUT_WIDTH / NUM_HORIZONTAL_PIXELS_PER_ITERATION;
    f16vec4 result[NUM_HORIZONTAL_ITERATIONS];

    for (int iter = 0; iter < NUM_HORIZONTAL_ITERATIONS; iter++)
    {
        // Filter vertically.
        f16vec4 tmp = f16vec4(0.0);

        int off_x = int(local_index) / OUTPUT_HEIGHT + NUM_HORIZONTAL_PIXELS_PER_ITERATION * iter;
        int off_y = int(local_index) % OUTPUT_HEIGHT;

        precise int shared_coord_y =
            int(float(PHASES) * (base_input.y + registers.scaling_to_input.y * float(off_y)) + 0.5);
        int shared_phase = int(bitfieldExtract(uint(shared_coord_y), 0, PHASES_BITS));
        shared_coord_y >>= PHASES_BITS;
        shared_coord_y -= int(base_input.y);

        for (int i = 0; i < TAPS_HALF; i++)
        {
            f16vec2 w = weights[TAPS_HALF * PHASES + shared_phase * TAPS_HALF + i];

            f16vec2 rg0 = shared_rg[shared_coord_y + 2 * i + 0][off_x];
            f16vec2 rg1 = shared_rg[shared_coord_y + 2 * i + 1][off_x];
            f16vec2 ba0 = shared_ba[shared_coord_y + 2 * i + 0][off_x];
            f16vec2 ba1 = shared_ba[shared_coord_y + 2 * i + 1][off_x];
            tmp += f16vec4(rg0, ba0) * w.x + f16vec4(rg1, ba1) * w.y;
        }

        result[iter] = tmp;
    }

    barrier();

    for (int iter = 0; iter < NUM_HORIZONTAL_ITERATIONS; iter++)
    {
        int off_x = int(local_index) / OUTPUT_HEIGHT + NUM_HORIZONTAL_PIXELS_PER_ITERATION * iter;
        int off_y = int(local_index) % OUTPUT_HEIGHT;
        shared_rg[off_y][off_x] = result[iter].rg;
        shared_ba[off_y][off_x] = result[iter].ba;
    }

    barrier();

    // Filter horizontally.
    f16vec4 tmp = f16vec4(0.0);

    precise int shared_coord_x =
        int(float(PHASES) * (base_input.x + registers.scaling_to_input.x * float(unswizzle_coord.x)) + 0.5);
    int shared_phase = int(bitfieldExtract(uint(shared_coord_x), 0, PHASES_BITS));
    shared_coord_x >>= PHASES_BITS;
    shared_coord_x -= int(base_input.x);

    for (int i = 0; i < TAPS_HALF; i++)
    {
        f16vec2 w = weights[shared_phase * TAPS_HALF + i];
        f16vec2 rg0 = shared_rg[unswizzle_coord.y][shared_coord_x + 2 * i + 0];
        f16vec2 rg1 = shared_rg[unswizzle_coord.y][shared_coord_x + 2 * i + 1];
        f16vec2 ba0 = shared_ba[unswizzle_coord.y][shared_coord_x + 2 * i + 0];
        f16vec2 ba1 = shared_ba[unswizzle_coord.y][shared_coord_x + 2 * i + 1];
        tmp += f16vec4(rg0, ba0) * w.x + f16vec4(rg1, ba1) * w.y;
    }

    imageStore(uOutput, base_output + unswizzle_coord, tmp);
}