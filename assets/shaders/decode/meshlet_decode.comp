#version 450

#extension GL_EXT_scalar_block_layout : require
#include "../inc/meshlet_payload_constants.h"
#extension GL_KHR_shader_subgroup_basic : require

layout(local_size_x = 256) in;

layout(constant_id = 0) const uint NUM_U32_STREAMS = MESHLET_PAYLOAD_MAX_STREAMS;
layout(constant_id = 1) const bool UNROLLED_MESH = false;
layout(constant_id = 2) const uint TARGET_MESH_STYLE = 0;

#define MESHLET_PAYLOAD_DESCRIPTOR_SET 0
#define MESHLET_PAYLOAD_META_BINDING 0
#define MESHLET_PAYLOAD_STREAM_BINDING 1
#define MESHLET_PAYLOAD_PAYLOAD_BINDING 2
#include "../inc/meshlet_payload_decode.h"
#include "../inc/meshlet_attribute_decode.h"

const int MESH_STYLE_WIREFRAME = 0;
const int MESH_STYLE_TEXTURED = 1;
const int MESH_STYLE_SKINNED = 2;

layout(set = 0, binding = 3, scalar) writeonly buffer OutputIndices
{
    uvec3 data[];
} output_indices32;

layout(set = 0, binding = 3, scalar) writeonly buffer OutputIndices8
{
    u8vec3 data[];
} output_indices8;

layout(set = 0, binding = 4, scalar) writeonly buffer OutputStreamPos
{
    vec3 data[];
} output_stream_pos;

struct TexturedAttr
{
    uint normal;
    uint tangent;
    vec2 uv;
};

layout(set = 0, binding = 5, std430) writeonly buffer OutputStreamTextured
{
    TexturedAttr data[];
} output_stream_textured_attr;

layout(set = 0, binding = 6, std430) writeonly buffer OutputStreamSkin
{
    uvec2 data[];
} output_stream_skin;

layout(set = 0, binding = 7, std430) readonly buffer OutputOffsets
{
    uint data[];
} primitive_output_offsets;

#if MESHLET_PAYLOAD_RUNTIME_MESH
struct IndirectDrawMesh
{
    uint primitive_offset;
    uint vertex_offset;
    uint num_primitives;
    uint num_attributes;
};

layout(set = 0, binding = 8, std430) writeonly buffer IndirectCommands
{
    IndirectDrawMesh draws[];
} indirect_commands_mesh;
#else
struct IndirectIndexedDraw
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

layout(set = 0, binding = 8, std430) writeonly buffer IndirectCommands
{
    IndirectIndexedDraw draws[];
} indirect_commands;
#endif

layout(push_constant, std430) uniform Registers
{
    uint primitive_offset;
    uint vertex_offset;
    uint meshlet_offset;
} registers;

uint pack_a2bgr10(vec4 v)
{
    ivec4 quantized = ivec4(round(clamp(v, vec4(-1.0), vec4(1.0)) * vec4(511.0, 511.0, 511.0, 1.0))) & ivec4(1023, 1023, 1023, 3);
    return (quantized.a << 30) | (quantized.b << 20) | (quantized.g << 10) | (quantized.r << 0);
}

void main()
{
    uint meshlet_index = gl_WorkGroupID.x;
    MeshletMetaRaw meta = meshlet_metas_raw.data[meshlet_index];

    int lane_index;
    uint chunk_index;
    uint linear_index;

    if (gl_SubgroupSize == 32)
    {
        chunk_index = gl_SubgroupID;
        lane_index = int(gl_SubgroupInvocationID);
        linear_index = chunk_index * gl_SubgroupSize + lane_index;
    }
    else
    {
        linear_index = gl_LocalInvocationIndex;
        chunk_index = linear_index / 32u;
        lane_index = int(linear_index & 31u);
    }

    uint primitive_output_offset = primitive_output_offsets.data[meshlet_index] + registers.primitive_offset;

    if (!UNROLLED_MESH && gl_LocalInvocationIndex == 0)
    {
        MeshletInfo info = meshlet_get_meshlet_info(meshlet_index * NUM_U32_STREAMS);
#if MESHLET_PAYLOAD_RUNTIME_MESH
        IndirectDrawMesh draw;
        draw.primitive_offset = primitive_output_offset;
        draw.vertex_offset = meta.base_vertex_offset + registers.vertex_offset;
        draw.num_primitives = info.num_primitives;
        draw.num_attributes = info.num_attributes;
        indirect_commands_mesh.draws[meshlet_index + registers.meshlet_offset] = draw;
#else
        IndirectIndexedDraw draw;
        draw.indexCount = 3 * info.primitive_count;
        draw.instanceCount = 1;
        draw.vertexOffset = meta.base_vertex_offset + registers.vertex_offset;
        draw.firstIndex = 3 * primitive_output_offset;
        draw.firstInstance = 0;
        indirect_commands.draws[meshlet_index + registers.meshlet_offset] = draw;
#endif
    }

    if (chunk_index >= meta.num_chunks)
        return;

    MeshletChunkInfo chunk_info = meshlet_get_chunk_info(meshlet_index * NUM_U32_STREAMS, chunk_index);

    // Index
    if (lane_index < chunk_info.primitive_count)
    {
        uint decoded_index_buffer = meshlet_decode_index_buffer(meshlet_index * NUM_U32_STREAMS,
                chunk_index, lane_index);

        primitive_output_offset += chunk_info.primitive_offset;

        uvec3 indices;
        indices.x = bitfieldExtract(decoded_index_buffer, 0, 8);
        indices.y = bitfieldExtract(decoded_index_buffer, 8, 8);
        indices.z = bitfieldExtract(decoded_index_buffer, 16, 8);
        indices += chunk_info.vertex_offset;

        if (UNROLLED_MESH)
            output_indices32.data[primitive_output_offset + lane_index] = indices + meta.base_vertex_offset + registers.vertex_offset;
        else
            output_indices8.data[primitive_output_offset + lane_index] = u8vec3(indices);
    }

    // Attributes
    if (lane_index < chunk_info.vertex_count)
    {
        int exponent;
        i16vec3 pos = meshlet_decode_snorm_scaled_i16x3(meshlet_index * NUM_U32_STREAMS + 1, chunk_index, lane_index, exponent);
        vec3 fp_pos = ldexp(vec3(pos), ivec3(exponent));
        uint vertex_output_offset = registers.vertex_offset + meta.base_vertex_offset + chunk_info.vertex_offset;
        output_stream_pos.data[vertex_output_offset + lane_index] = fp_pos;
    }
}
