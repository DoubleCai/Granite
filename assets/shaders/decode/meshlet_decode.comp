#version 450
#extension GL_EXT_shader_explicit_arithmetic_types_int8 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : require
#extension GL_KHR_shader_subgroup_arithmetic : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_EXT_shader_subgroup_extended_types_int8 : require
#extension GL_EXT_scalar_block_layout : require

#define MAX_ELEMENTS 256
#define NUM_CHUNKS 8

layout(local_size_x = 32, local_size_y = NUM_CHUNKS) in;

layout(constant_id = 0) const uint NUM_U32_STREAMS = 1;

struct MeshletStream
{
    u16vec4 predictor_a;
    u16vec4 predictor_b;
    u8vec4 initial_value;
    uint offset_from_base;
    uint16_t bitplane_meta[NUM_CHUNKS];
};

struct MeshletMeta
{
    uint base_vertex_offset;
    uint8_t num_primitives_minus_1;
    uint8_t num_attributes_minus_1;
    uint16_t reserved;
};

layout(set = 0, binding = 0, std430) readonly buffer MeshletMetas
{
    MeshletMeta data[];
} meshlet_metas;

layout(set = 0, binding = 1, std430) readonly buffer MeshletStreams
{
    MeshletStream data[];
} meshlet_streams;

layout(set = 0, binding = 2, std430) writeonly buffer OutputAttributes
{
    uint data[];
} output_payload;

layout(set = 0, binding = 3, scalar) writeonly buffer OutputIndices
{
    uvec3 data[];
} output_indices;

layout(set = 0, binding = 4, std430) readonly buffer Payload
{
    uint data[];
} payload;

layout(set = 0, binding = 5, std430) readonly buffer OutputOffsets
{
    uvec2 data[];
} output_offset_strides;

shared u16vec4 shared_chunk_bit_counts[NUM_U32_STREAMS][NUM_CHUNKS];
shared uint shared_chunk_offset[NUM_U32_STREAMS][NUM_CHUNKS];
shared u8vec4 chunk_values[NUM_CHUNKS];

// Hardcodes wave32 atm. Need fallback.

void main()
{
    uint meshlet_index = gl_WorkGroupID.x;
    int subgroup_lane = int(gl_SubgroupInvocationID);

    for (uint stream_index = gl_SubgroupID; stream_index < NUM_U32_STREAMS; stream_index += gl_NumSubgroups)
    {
        // Start by decoding the offset for bitplanes for all u32 streams.
        if (subgroup_lane < int(gl_WorkGroupSize.y))
        {
            uint bitplane_value = uint(meshlet_streams.data[stream_index + NUM_U32_STREAMS * meshlet_index].bitplane_meta[subgroup_lane]);
            u16vec4 bit_counts = (u16vec4(bitplane_value) >> u16vec4(0, 4, 8, 12)) & 0xfus;
            u16vec2 bit_counts2 = bit_counts.xy + bit_counts.zw;
            uint total_bits = bit_counts2.x + bit_counts2.y;
            uint offset = meshlet_streams.data[stream_index + NUM_U32_STREAMS * meshlet_index].offset_from_base;
            shared_chunk_offset[stream_index][subgroup_lane] = subgroupExclusiveAdd(total_bits) + offset;
            shared_chunk_bit_counts[stream_index][subgroup_lane] = bit_counts;
        }
    }

    barrier();

    MeshletMeta meta = meshlet_metas.data[meshlet_index];

    uint unrolled_stream_index = NUM_U32_STREAMS * meshlet_index;

    for (uint i = 0; i < NUM_U32_STREAMS; i++, unrolled_stream_index++)
    {
        uint offset_from_base = meshlet_streams.data[unrolled_stream_index].offset_from_base;
        u16vec4 predictor_a = meshlet_streams.data[unrolled_stream_index].predictor_a;
        u16vec4 predictor_b = meshlet_streams.data[unrolled_stream_index].predictor_b;
        u8vec4 initial_value = meshlet_streams.data[unrolled_stream_index].initial_value;

        uint chunk_id = gl_SubgroupID;
        uint bitplane_offsets = shared_chunk_offset[i][chunk_id];
        ivec4 bit_counts = ivec4(shared_chunk_bit_counts[i][chunk_id]);

        uvec4 decoded = ivec4(0);

        for (int i = 0; i < bit_counts.x; i++)
        {
            uint value = payload.data[bitplane_offsets++];
            decoded.x |= bitfieldExtract(value, subgroup_lane, 1) << i;
        }
        decoded.x = bitfieldExtract(int(decoded.x), 0, bit_counts.x);

        for (int i = 0; i < bit_counts.y; i++)
        {
            uint value = payload.data[bitplane_offsets++];
            decoded.y |= bitfieldExtract(value, subgroup_lane, 1) << i;
        }
        decoded.y = bitfieldExtract(int(decoded.y), 0, bit_counts.y);

        for (int i = 0; i < bit_counts.z; i++)
        {
            uint value = payload.data[bitplane_offsets++];
            decoded.z |= bitfieldExtract(value, subgroup_lane, 1) << i;
        }
        decoded.z = bitfieldExtract(int(decoded.z), 0, bit_counts.z);

        for (int i = 0; i < bit_counts.w; i++)
        {
            uint value = payload.data[bitplane_offsets++];
            decoded.w |= bitfieldExtract(value, subgroup_lane, 1) << i;
        }
        decoded.w = bitfieldExtract(int(decoded.w), 0, bit_counts.w);

        // Resolve deltas in packed 4x8 math.
        u8vec4 packed_decoded = u8vec4(decoded);
        uint linear_index = chunk_id * gl_WorkGroupSize.x + subgroup_lane;
        if (linear_index == 0)
            packed_decoded += initial_value;
        packed_decoded += u8vec4((predictor_a + predictor_b * uint16_t(linear_index)) >> 8us);
        packed_decoded = subgroupInclusiveAdd(packed_decoded);

        if (i > 0)
            barrier(); // Resolve WAR hazard from last iteration.
        if (subgroup_lane == int(gl_SubgroupSize) - 1)
            chunk_values[chunk_id] = packed_decoded;
        barrier();
        if (gl_SubgroupID == 0u && subgroup_lane < int(gl_WorkGroupSize.y))
            chunk_values[subgroup_lane] = subgroupInclusiveAdd(chunk_values[subgroup_lane]);
        barrier();
        if (chunk_id != 0)
            packed_decoded += chunk_values[chunk_id - 1];

        if (i == 0)
        {
            // Write index buffer.
            uvec3 indices = uvec3(packed_decoded.xyz);
            indices += meta.base_vertex_offset;
            uint output_offset = output_offset_strides.data[unrolled_stream_index].x;
            if (linear_index <= uint(meta.num_primitives_minus_1))
                output_indices.data[output_offset + linear_index] = indices;
        }
        else
        {
            // TODO: decode filters? Should probably be deferred to vertex / mesh shader.
            uvec2 output_offset_stride = output_offset_strides.data[unrolled_stream_index];
            if (linear_index <= uint(meta.num_attributes_minus_1))
                output_payload.data[output_offset_stride.x + linear_index * output_offset_stride.y] = pack32(packed_decoded);
        }
    }
}
